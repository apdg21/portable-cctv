<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SecureCam - Secure Video Surveillance</title>
    <style>
        :root {
            --primary-color: #2563eb;
            --primary-dark: #1d4ed8;
            --danger-color: #dc2626;
            --success-color: #16a34a;
            --warning-color: #d97706;
            --gray-100: #f3f4f6;
            --gray-200: #e5e7eb;
            --gray-300: #d1d5db;
            --gray-600: #4b5563;
            --gray-700: #374151;
            --gray-800: #1f2937;
            --gray-900: #111827;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--gray-100);
            color: var(--gray-900);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        header {
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
        }
        
        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-color);
        }
        
        .nav-buttons {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 0.375rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }
        
        .btn-primary:hover {
            background-color: var(--primary-dark);
        }
        
        .btn-danger {
            background-color: var(--danger-color);
            color: white;
        }
        
        .btn-danger:hover {
            background-color: #b91c1c;
        }
        
        .btn-success {
            background-color: var(--success-color);
            color: white;
        }
        
        .btn-success:hover {
            background-color: #15803d;
        }
        
        .btn-outline {
            background-color: transparent;
            border: 1px solid var(--gray-300);
            color: var(--gray-700);
        }
        
        .btn-outline:hover {
            background-color: var(--gray-100);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        main {
            padding: 2rem 0;
        }
        
        .section {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--gray-900);
        }
        
        .auth-section {
            max-width: 400px;
            margin: 2rem auto;
        }
        
        .form-group {
            margin-bottom: 1rem;
        }
        
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--gray-700);
        }
        
        input, select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--gray-300);
            border-radius: 0.375rem;
            font-size: 1rem;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }
        
        .form-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        
        .cameras-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
        }
        
        .camera-card {
            border: 1px solid var(--gray-200);
            border-radius: 0.5rem;
            padding: 1.5rem;
            background: white;
        }
        
        .camera-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 1rem;
        }
        
        .camera-name {
            font-weight: 600;
            font-size: 1.125rem;
            color: var(--gray-900);
        }
        
        .camera-location {
            color: var(--gray-600);
            margin-bottom: 0.5rem;
        }
        
        .camera-status {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 500;
        }
        
        .status-online {
            background-color: #dcfce7;
            color: #166534;
        }
        
        .status-offline {
            background-color: #f3f4f6;
            color: var(--gray-600);
        }
        
        .status-streaming {
            background-color: #dbeafe;
            color: var(--primary-dark);
        }
        
        .camera-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        
        .streaming-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }
        
        .video-container {
            position: relative;
            background: var(--gray-900);
            border-radius: 0.5rem;
            overflow: hidden;
            aspect-ratio: 16/9;
        }
        
        .video-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--gray-400);
            background: var(--gray-800);
        }
        
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .stream-controls {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .stream-info {
            background: var(--gray-50);
            padding: 1rem;
            border-radius: 0.375rem;
            margin-top: 1rem;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }
        
        .info-item {
            display: flex;
            flex-direction: column;
        }
        
        .info-label {
            font-size: 0.875rem;
            color: var(--gray-600);
        }
        
        .info-value {
            font-weight: 600;
            color: var(--gray-900);
        }
        
        .events-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .event-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            border-bottom: 1px solid var(--gray-200);
        }
        
        .event-item:last-child {
            border-bottom: none;
        }
        
        .event-type {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
        }
        
        .type-info {
            background-color: #dbeafe;
            color: var(--primary-dark);
        }
        
        .type-warning {
            background-color: #fef3c7;
            color: var(--warning-color);
        }
        
        .type-success {
            background-color: #dcfce7;
            color: var(--success-color);
        }
        
        .alert {
            padding: 1rem;
            border-radius: 0.375rem;
            margin-bottom: 1rem;
        }
        
        .alert-error {
            background-color: #fef2f2;
            border: 1px solid #fecaca;
            color: var(--danger-color);
        }
        
        .alert-success {
            background-color: #f0fdf4;
            border: 1px solid #bbf7d0;
            color: var(--success-color);
        }
        
        .alert-info {
            background-color: #eff6ff;
            border: 1px solid #dbeafe;
            color: var(--primary-color);
        }
        
        .hidden {
            display: none !important;
        }
        
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
        
        .metrics-panel {
            background: var(--gray-50);
            padding: 1rem;
            border-radius: 0.375rem;
            margin-top: 1rem;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
        }
        
        .metric-item {
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-color);
        }
        
        .metric-label {
            font-size: 0.875rem;
            color: var(--gray-600);
        }
        
        @media (max-width: 768px) {
            .streaming-section {
                grid-template-columns: 1fr;
            }
            
            .cameras-grid {
                grid-template-columns: 1fr;
            }
            
            .header-content {
                flex-direction: column;
                gap: 1rem;
            }
            
            .nav-buttons {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo">SecureCam</div>
                <div class="nav-buttons">
                    <button id="loginBtn" class="btn btn-outline">Login</button>
                    <button id="registerBtn" class="btn btn-outline">Register</button>
                    <button id="logoutBtn" class="btn btn-outline hidden">Logout</button>
                </div>
            </div>
        </div>
    </header>

    <main class="container">
        <!-- Auth Section -->
        <section id="authSection" class="section auth-section">
            <div class="section-header">
                <h2 class="section-title" id="authTitle">Login</h2>
            </div>
            
            <div id="authAlert" class="alert hidden"></div>
            
            <form id="authForm">
                <div class="form-group" id="nameGroup">
                    <label for="name">Full Name</label>
                    <input type="text" id="name" name="name" required>
                </div>
                
                <div class="form-group">
                    <label for="email">Email</label>
                    <input type="email" id="email" name="email" required>
                </div>
                
                <div class="form-group">
                    <label for="password">Password</label>
                    <input type="password" id="password" name="password" required minlength="6">
                </div>
                
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary" id="authSubmit">
                        <span id="authSubmitText">Login</span>
                    </button>
                    <button type="button" class="btn btn-outline" id="authSwitch">
                        Switch to Register
                    </button>
                </div>
            </form>
        </section>

        <!-- Main App Section -->
        <section id="appSection" class="hidden">
            <!-- Cameras Section -->
            <section class="section">
                <div class="section-header">
                    <h2 class="section-title">My Cameras</h2>
                    <button id="addCameraBtn" class="btn btn-primary">Add Camera</button>
                </div>
                
                <div id="camerasAlert" class="alert hidden"></div>
                
                <div class="cameras-grid" id="camerasGrid">
                    <!-- Camera cards will be populated here -->
                </div>
            </section>

            <!-- Streaming Section -->
            <section class="section">
                <div class="section-header">
                    <h2 class="section-title">Live Streaming</h2>
                </div>
                
                <div id="streamingAlert" class="alert hidden"></div>
                
                <div class="streaming-section">
                    <!-- Streamer Side -->
                    <div>
                        <h3>Camera Stream</h3>
                        <div class="video-container">
                            <video id="localVideo" autoplay muted playsinline></video>
                            <div id="localVideoPlaceholder" class="video-placeholder">
                                Camera feed will appear here
                            </div>
                        </div>
                        
                        <div class="stream-controls">
                            <button id="startStreamBtn" class="btn btn-success">Start Streaming</button>
                            <button id="stopStreamBtn" class="btn btn-danger hidden">Stop Streaming</button>
                            <button id="refreshCamerasBtn" class="btn btn-outline">Refresh Cameras</button>
                        </div>
                        
                        <div id="streamerInfo" class="stream-info hidden">
                            <div class="info-grid">
                                <div class="info-item">
                                    <span class="info-label">Stream ID</span>
                                    <span class="info-value" id="streamIdValue">-</span>
                                </div>
                                <div class="info-item">
                                    <span class="info-label">Status</span>
                                    <span class="info-value" id="streamStatus">-</span>
                                </div>
                                <div class="info-item">
                                    <span class="info-label">Viewers</span>
                                    <span class="info-value" id="viewerCount">0</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Viewer Side -->
                    <div>
                        <h3>Viewer Stream</h3>
                        <div class="video-container">
                            <video id="remoteVideo" autoplay playsinline></video>
                            <div id="remoteVideoPlaceholder" class="video-placeholder">
                                Remote stream will appear here
                            </div>
                        </div>
                        
                        <div class="stream-controls">
                            <button id="startViewerBtn" class="btn btn-primary">Start Viewer</button>
                            <button id="stopViewerBtn" class="btn btn-danger hidden">Stop Viewer</button>
                            <select id="streamSelector">
                                <option value="">Select a stream...</option>
                            </select>
                        </div>
                        
                        <div id="viewerInfo" class="stream-info hidden">
                            <div class="info-grid">
                                <div class="info-item">
                                    <span class="info-label">Connection</span>
                                    <span class="info-value" id="connectionStatus">Disconnected</span>
                                </div>
                                <div class="info-item">
                                    <span class="info-label">Stream Quality</span>
                                    <span class="info-value" id="streamQuality">-</span>
                                </div>
                                <div class="info-item">
                                    <span class="info-label">Latency</span>
                                    <span class="info-value" id="streamLatency">-</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Connection Metrics -->
                <div id="metricsPanel" class="metrics-panel hidden">
                    <h4>Connection Metrics</h4>
                    <div class="metrics-grid">
                        <div class="metric-item">
                            <div class="metric-value" id="metricBitrate">0</div>
                            <div class="metric-label">Bitrate (kbps)</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value" id="metricPackets">0</div>
                            <div class="metric-label">Packets/s</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value" id="metricJitter">0</div>
                            <div class="metric-label">Jitter (ms)</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value" id="metricRtt">0</div>
                            <div class="metric-label">RTT (ms)</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Events Section -->
            <section class="section">
                <div class="section-header">
                    <h2 class="section-title">Recent Events</h2>
                    <button id="refreshEventsBtn" class="btn btn-outline">Refresh</button>
                </div>
                
                <div class="events-list" id="eventsList">
                    <!-- Events will be populated here -->
                </div>
            </section>
        </section>
    </main>

    <!-- Add Camera Modal -->
    <div id="cameraModal" class="modal hidden" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000;">
        <div style="background: white; padding: 2rem; border-radius: 0.5rem; width: 90%; max-width: 400px;">
            <h3 style="margin-bottom: 1rem;">Add New Camera</h3>
            <form id="cameraForm">
                <div class="form-group">
                    <label for="cameraName">Camera Name</label>
                    <input type="text" id="cameraName" name="name" required>
                </div>
                
                <div class="form-group">
                    <label for="cameraLocation">Location</label>
                    <input type="text" id="cameraLocation" name="location" required>
                </div>
                
                <div class="form-group">
                    <label for="cameraQuality">Stream Quality</label>
                    <select id="cameraQuality" name="quality">
                        <option value="low">Low (480p)</option>
                        <option value="medium" selected>Medium (720p)</option>
                        <option value="high">High (1080p)</option>
                    </select>
                </div>
                
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Add Camera</button>
                    <button type="button" class="btn btn-outline" id="cancelCameraBtn">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // API configuration
        const API_BASE_URL = window.location.origin;
        
        // Global state
        let authToken = null;
        let currentUser = null;
        let cameras = [];
        let activeStreams = [];
        let events = [];
        
        // WebRTC state
        let peerConnection = null;
        let localStream = null;
        let currentSessionId = null;
        let isInitiator = false;
        let pollingInterval = null;
        let metricsInterval = null;
        let streamStartTime = null;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;
        
        // DOM elements
        const elements = {
            // Auth
            authSection: document.getElementById('authSection'),
            appSection: document.getElementById('appSection'),
            authTitle: document.getElementById('authTitle'),
            authForm: document.getElementById('authForm'),
            authAlert: document.getElementById('authAlert'),
            authSubmit: document.getElementById('authSubmit'),
            authSubmitText: document.getElementById('authSubmitText'),
            authSwitch: document.getElementById('authSwitch'),
            nameGroup: document.getElementById('nameGroup'),
            loginBtn: document.getElementById('loginBtn'),
            registerBtn: document.getElementById('registerBtn'),
            logoutBtn: document.getElementById('logoutBtn'),
            
            // Cameras
            camerasGrid: document.getElementById('camerasGrid'),
            camerasAlert: document.getElementById('camerasAlert'),
            addCameraBtn: document.getElementById('addCameraBtn'),
            cameraModal: document.getElementById('cameraModal'),
            cameraForm: document.getElementById('cameraForm'),
            cancelCameraBtn: document.getElementById('cancelCameraBtn'),
            refreshCamerasBtn: document.getElementById('refreshCamerasBtn'),
            
            // Streaming
            localVideo: document.getElementById('localVideo'),
            localVideoPlaceholder: document.getElementById('localVideoPlaceholder'),
            remoteVideo: document.getElementById('remoteVideo'),
            remoteVideoPlaceholder: document.getElementById('remoteVideoPlaceholder'),
            startStreamBtn: document.getElementById('startStreamBtn'),
            stopStreamBtn: document.getElementById('stopStreamBtn'),
            startViewerBtn: document.getElementById('startViewerBtn'),
            stopViewerBtn: document.getElementById('stopViewerBtn'),
            streamSelector: document.getElementById('streamSelector'),
            streamingAlert: document.getElementById('streamingAlert'),
            streamerInfo: document.getElementById('streamerInfo'),
            viewerInfo: document.getElementById('viewerInfo'),
            streamIdValue: document.getElementById('streamIdValue'),
            streamStatus: document.getElementById('streamStatus'),
            viewerCount: document.getElementById('viewerCount'),
            connectionStatus: document.getElementById('connectionStatus'),
            streamQuality: document.getElementById('streamQuality'),
            streamLatency: document.getElementById('streamLatency'),
            
            // Metrics
            metricsPanel: document.getElementById('metricsPanel'),
            metricBitrate: document.getElementById('metricBitrate'),
            metricPackets: document.getElementById('metricPackets'),
            metricJitter: document.getElementById('metricJitter'),
            metricRtt: document.getElementById('metricRtt'),
            
            // Events
            eventsList: document.getElementById('eventsList'),
            refreshEventsBtn: document.getElementById('refreshEventsBtn')
        };

        // API service
        const API = {
            async request(endpoint, options = {}) {
                const url = `${API_BASE_URL}${endpoint}`;
                const config = {
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    },
                    ...options
                };
                
                if (authToken) {
                    config.headers.Authorization = `Bearer ${authToken}`;
                }
                
                try {
                    const response = await fetch(url, config);
                    const data = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(data.error || `HTTP ${response.status}`);
                    }
                    
                    return data;
                } catch (error) {
                    console.error(`API request failed: ${endpoint}`, error);
                    throw error;
                }
            },
            
            // Auth
            async register(userData) {
                return this.request('/api/register', {
                    method: 'POST',
                    body: JSON.stringify(userData)
                });
            },
            
            async login(credentials) {
                return this.request('/api/login', {
                    method: 'POST',
                    body: JSON.stringify(credentials)
                });
            },
            
            // Cameras
            async getCameras() {
                return this.request('/api/cameras');
            },
            
            async createCamera(cameraData) {
                return this.request('/api/cameras', {
                    method: 'POST',
                    body: JSON.stringify(cameraData)
                });
            },
            
            async deleteCamera(cameraId) {
                return this.request(`/api/cameras/${cameraId}/delete`, {
                    method: 'POST'
                });
            },
            
            // Streams
            async startStream(streamData) {
                return this.request('/api/streams/start', {
                    method: 'POST',
                    body: JSON.stringify(streamData)
                });
            },
            
            async stopStream(streamId) {
                return this.request(`/api/streams/${streamId}/stop`, {
                    method: 'POST'
                });
            },
            
            async getStreams() {
                return this.request('/api/streams');
            },
            
            async getStream(streamId) {
                return this.request(`/api/streams/${streamId}`);
            },
            
            // WebRTC
            async createWebRTCSession(sessionData) {
                return this.request('/api/webrtc/session', {
                    method: 'POST',
                    body: JSON.stringify(sessionData)
                });
            },
            
            async getWebRTCSession(streamId) {
                return this.request(`/api/webrtc/session/${streamId}`);
            },
            
            async pollWebRTCSession(streamId) {
                return this.request(`/api/webrtc/session/${streamId}/poll`);
            },
            
            async sendOffer(sessionId, offer) {
                return this.request(`/api/webrtc/session/${sessionId}/offer`, {
                    method: 'POST',
                    body: JSON.stringify({ offer })
                });
            },
            
            async sendAnswer(sessionId, answer) {
                return this.request(`/api/webrtc/session/${sessionId}/answer`, {
                    method: 'POST',
                    body: JSON.stringify({ answer })
                });
            },
            
            async sendCandidate(sessionId, candidate) {
                return this.request(`/api/webrtc/session/${sessionId}/candidate`, {
                    method: 'POST',
                    body: JSON.stringify({ candidate })
                });
            },
            
            async leaveWebRTCSession(sessionId) {
                return this.request(`/api/webrtc/session/${sessionId}/leave`, {
                    method: 'POST'
                });
            },
            
            // Events
            async getEvents() {
                return this.request('/api/events');
            }
        };

        // Auth management
        const AuthManager = {
            isLoggedIn() {
                return !!authToken;
            },
            
            async login(credentials) {
                try {
                    const result = await API.login(credentials);
                    this.setAuth(result.token, result.user);
                    this.showAlert('Login successful!', 'success');
                    return result;
                } catch (error) {
                    this.showAlert(error.message, 'error');
                    throw error;
                }
            },
            
            async register(userData) {
                try {
                    const result = await API.register(userData);
                    this.setAuth(result.token, result.user);
                    this.showAlert('Registration successful!', 'success');
                    return result;
                } catch (error) {
                    this.showAlert(error.message, 'error');
                    throw error;
                }
            },
            
            logout() {
                authToken = null;
                currentUser = null;
                localStorage.removeItem('authToken');
                localStorage.removeItem('user');
                this.updateUI();
                this.showAlert('Logged out successfully', 'success');
            },
            
            setAuth(token, user) {
                authToken = token;
                currentUser = user;
                localStorage.setItem('authToken', token);
                localStorage.setItem('user', JSON.stringify(user));
                this.updateUI();
            },
            
            loadFromStorage() {
                const token = localStorage.getItem('authToken');
                const user = localStorage.getItem('user');
                
                if (token && user) {
                    authToken = token;
                    currentUser = JSON.parse(user);
                    this.updateUI();
                    return true;
                }
                return false;
            },
            
            updateUI() {
                const isAuthenticated = this.isLoggedIn();
                
                elements.authSection.classList.toggle('hidden', isAuthenticated);
                elements.appSection.classList.toggle('hidden', !isAuthenticated);
                elements.loginBtn.classList.toggle('hidden', isAuthenticated);
                elements.registerBtn.classList.toggle('hidden', isAuthenticated);
                elements.logoutBtn.classList.toggle('hidden', !isAuthenticated);
                
                if (isAuthenticated) {
                    AppManager.init();
                } else {
                    WebRTCManager.disconnectViewer();
                    WebRTCManager.stopStreaming();
                }
            },
            
            showAlert(message, type = 'error') {
                elements.authAlert.textContent = message;
                elements.authAlert.className = `alert alert-${type}`;
                elements.authAlert.classList.remove('hidden');
                
                setTimeout(() => {
                    elements.authAlert.classList.add('hidden');
                }, 5000);
            }
        };

        // Enhanced WebRTC Manager with Complete Connection Handling
const WebRTCManager = {
    peerConnection: null,
    isInitiator: false,
    sessionId: null,
    currentCameraId: null,
    streamStartTime: null,
    pollingInterval: null,
    isStreamingActive: false,
    reconnectAttempts: 0,
    maxReconnectAttempts: 3,
    connectionState: 'disconnected',

    // Enhanced streaming initialization
    startStreaming: async function(cameraId, cameraName, stream) {
        try {
            console.log('🚀 Starting WebRTC streaming for camera:', cameraId);
            
            this.currentCameraId = cameraId;
            this.connectionState = 'connecting';
            
            // Create WebRTC session on server
            const sessionResult = await API.createWebRTCSession(cameraId, cameraName);

            if (!sessionResult.success) {
                throw new Error(sessionResult.error || 'Failed to create WebRTC session');
            }

            this.sessionId = sessionResult.sessionId;
            this.isInitiator = true;
            this.isStreamingActive = true;
            this.reconnectAttempts = 0;
            
            console.log('✅ WebRTC session created:', this.sessionId);
            
            // Initialize WebRTC as streamer
            await this.initWebRTC(true);
            
            // Add local stream tracks to the connection
            if (stream) {
                console.log('📹 Adding local stream tracks:', stream.getTracks().length);
                stream.getTracks().forEach(track => {
                    this.peerConnection.addTrack(track, stream);
                });
            }

            // Create and send offer
            const offerOptions = {
                offerToReceiveAudio: false,
                offerToReceiveVideo: false
            };
            
            console.log('📨 Creating WebRTC offer...');
            const offer = await this.peerConnection.createOffer(offerOptions);
            await this.peerConnection.setLocalDescription(offer);

            console.log('📤 Sending offer to server...');
            await API.sendWebRTCOffer(this.sessionId, offer);

            console.log('✅ WebRTC streaming started successfully');
            
            // Update UI for streamer
            this.updateStreamerUI();
            
            // Start polling for viewer answers and ICE candidates
            this.startPollingForViewers();
            
            this.streamStartTime = new Date();
            this.connectionState = 'connected';

            return { 
                success: true, 
                sessionId: this.sessionId,
                message: 'WebRTC streaming started successfully'
            };
        } catch (error) {
            console.error('❌ Error starting WebRTC streaming:', error);
            this.connectionState = 'failed';
            return { success: false, error: error.message };
        }
    },

    // Enhanced polling for streamer
    startPollingForViewers: function() {
        if (this.pollingInterval) clearInterval(this.pollingInterval);
        
        this.pollingInterval = setInterval(async () => {
            try {
                if (!this.isInitiator || !this.sessionId) return;

                // Get answers from viewers
                const answersResponse = await API.getWebRTCSessionAnswers(this.sessionId);
                
                if (answersResponse.success && answersResponse.answers.length > 0) {
                    console.log('📥 Processing viewer answers:', answersResponse.answers.length);
                    for (const answer of answersResponse.answers) {
                        try {
                            if (this.peerConnection.signalingState === 'have-local-offer') {
                                await this.peerConnection.setRemoteDescription(answer);
                                console.log('✅ Remote description set from viewer answer');
                            }
                        } catch (error) {
                            console.error('❌ Error setting remote description:', error);
                        }
                    }
                }

                // Get ICE candidates from viewers
                const candidatesResponse = await API.getWebRTCSessionCandidates(this.sessionId);
                
                if (candidatesResponse.success && candidatesResponse.candidates.length > 0) {
                    console.log('🧊 Processing viewer ICE candidates:', candidatesResponse.candidates.length);
                    for (const candidate of candidatesResponse.candidates) {
                        try {
                            await this.peerConnection.addIceCandidate(candidate);
                            console.log('✅ Added ICE candidate from viewer');
                        } catch (error) {
                            // This is often normal - candidate might already be added
                            if (error.toString().includes('already')) {
                                console.log('ℹ️ ICE candidate already added (normal)');
                            } else {
                                console.error('❌ Error adding ICE candidate:', error);
                            }
                        }
                    }
                }

                // Update viewer count
                if (answersResponse.viewerCount !== undefined) {
                    this.updateViewerCount(answersResponse.viewerCount);
                }
                
            } catch (error) {
                console.error('❌ Error polling for viewers:', error);
            }
        }, 3000); // Poll every 3 seconds
    },

    // Enhanced viewer connection
    joinStream: async function(streamId) {
        try {
            console.log('👁️ Joining WebRTC stream:', streamId);
            
            // Clean up any existing connection
            if (this.peerConnection) {
                this.peerConnection.close();
                this.peerConnection = null;
            }

            this.sessionId = streamId;
            this.isInitiator = false;
            this.reconnectAttempts = 0;
            this.connectionState = 'connecting';
            
            // Initialize fresh WebRTC as viewer
            await this.initWebRTC(false);
            
            this.updateViewerUI('Connecting to WebRTC stream...');
            
            // Clear video element
            const videoElement = document.getElementById('camera-feed');
            if (videoElement) {
                videoElement.pause();
                videoElement.srcObject = null;
                videoElement.classList.add('hidden');
                document.getElementById('camera-placeholder').classList.remove('hidden');
            }
            
            // Start polling for streamer's offer
            this.startPollingForOffer();

            return { success: true };
        } catch (error) {
            console.error('❌ Error joining WebRTC stream:', error);
            this.connectionState = 'failed';
            return { success: false, error: error.message };
        }
    },

    // Enhanced WebRTC initialization
    initWebRTC: async function(isInitiator) {
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ],
            iceCandidatePoolSize: 10,
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require'
        };
        
        this.peerConnection = new RTCPeerConnection(configuration);
        this.isInitiator = isInitiator;

        console.log('🔧 WebRTC initialized as:', isInitiator ? 'Streamer' : 'Viewer');

        // Enhanced ICE candidate handling
        this.peerConnection.onicecandidate = (event) => {
            if (event.candidate && this.sessionId) {
                console.log('📤 Sending ICE candidate:', event.candidate.type);
                API.sendWebRTCCandidate(this.sessionId, event.candidate)
                    .catch(error => console.log('Note: Could not send candidate', error.message));
            }
        };

        // Enhanced connection state handling
        this.peerConnection.onconnectionstatechange = () => {
            if (!this.peerConnection) return;
            
            const state = this.peerConnection.connectionState;
            this.connectionState = state;
            console.log('🔗 WebRTC connection state:', state);
            
            if (state === 'connected') {
                console.log('✅ WebRTC connection established!');
                this.reconnectAttempts = 0;
                document.getElementById('stream-status').textContent = 
                    this.isInitiator ? 'Streaming to viewers' : 'Connected to stream';
                this.startConnectionMetrics();
                
                if (this.isInitiator) {
                    this.updateViewerCount();
                }
            } else if (state === 'disconnected' || state === 'failed') {
                console.log('❌ WebRTC connection failed:', state);
                this.handleConnectionFailure();
            }
        };

        // Enhanced track handling for viewers
        this.peerConnection.ontrack = (event) => {
            console.log('🎬 Received remote track:', event.track.kind);
            
            if (!this.isInitiator && event.streams && event.streams[0]) {
                const remoteStream = event.streams[0];
                console.log('📹 Remote stream received with tracks:', remoteStream.getTracks().length);
                
                const videoElement = document.getElementById('camera-feed');
                if (videoElement) {
                    videoElement.srcObject = null;
                    videoElement.srcObject = remoteStream;
                    videoElement.classList.remove('hidden');
                    
                    document.getElementById('camera-placeholder').classList.add('hidden');
                    document.getElementById('stream-status').textContent = 'Stream connected';
                    
                    // Auto-play with error handling
                    videoElement.play().catch(e => {
                        console.log('⚠️ Video play warning:', e.name);
                        videoElement.muted = true;
                        videoElement.play();
                    });
                }
            }
        };
    },

    // Enhanced polling for viewer
    startPollingForOffer: function() {
        if (this.pollingInterval) clearInterval(this.pollingInterval);
        
        let pollCount = 0;
        const maxPolls = 30; // 30 seconds timeout
        
        this.pollingInterval = setInterval(async () => {
            try {
                pollCount++;
                if (pollCount > maxPolls) {
                    console.log('⏰ Polling timeout reached');
                    clearInterval(this.pollingInterval);
                    this.updateViewerUI('Connection timeout - Stream may have ended');
                    return;
                }

                const result = await API.pollWebRTCSession(this.sessionId);
                
                console.log(`🔍 Poll ${pollCount}/${maxPolls}:`, {
                    hasOffer: result.hasOffer,
                    hasAnswer: result.hasAnswer,
                    candidateCount: result.candidates?.length || 0
                });

                if (result.success && result.hasOffer) {
                    // Get the full session data with offer
                    const sessionData = await API.getWebRTCSession(this.sessionId);
                    
                    if (sessionData.success && sessionData.session.offer) {
                        console.log('📥 Setting remote description from offer');
                        
                        // Set remote description (streamer's offer)
                        await this.peerConnection.setRemoteDescription(sessionData.session.offer);
                        
                        // Create and send answer
                        const answer = await this.peerConnection.createAnswer();
                        await this.peerConnection.setLocalDescription(answer);
                        
                        console.log('📤 Sending answer to streamer');
                        await API.sendWebRTCAnswer(this.sessionId, answer);

                        // Add existing ICE candidates from streamer
                        if (sessionData.session.candidates && sessionData.session.candidates.length > 0) {
                            console.log('🧊 Adding existing ICE candidates:', sessionData.session.candidates.length);
                            for (const candidate of sessionData.session.candidates) {
                                try {
                                    await this.peerConnection.addIceCandidate(candidate);
                                    console.log('✅ Added existing ICE candidate');
                                } catch (err) {
                                    console.log('ℹ️ ICE candidate add note (may be duplicate):', err.message);
                                }
                            }
                        }
                        
                        // Stop polling once connected
                        clearInterval(this.pollingInterval);
                        this.updateViewerUI('Connected to stream');
                        this.isStreamingActive = true;
                    }
                } else if (result.success && !result.isActive) {
                    console.log('🛑 Stream ended');
                    this.updateViewerUI('Stream has ended');
                    clearInterval(this.pollingInterval);
                    this.isStreamingActive = false;
                } else {
                    this.updateViewerUI(`Waiting for stream... (${pollCount}/${maxPolls})`);
                }
            } catch (error) {
                console.error('❌ Error polling for offer:', error);
                this.updateViewerUI('Connection error - Retrying...');
            }
        }, 1000);
    },

    // Enhanced disconnect with proper cleanup
    disconnectViewer: async function() {
        console.log('🔌 Disconnecting viewer...');
        
        // Notify backend that viewer is leaving
        if (this.sessionId && authToken) {
            try {
                await API.leaveWebRTCSession(this.sessionId);
                console.log('✅ Notified backend of viewer departure');
            } catch (error) {
                console.log('ℹ️ Note: Could not notify backend of departure', error.message);
            }
        }

        // Clean up WebRTC connection
        if (this.peerConnection) {
            this.peerConnection.close();
            this.peerConnection = null;
        }
        
        // Stop polling
        if (this.pollingInterval) {
            clearInterval(this.pollingInterval);
        }
        
        // Stop metrics
        this.stopConnectionMetrics();
        
        // Reset state
        this.sessionId = null;
        this.isInitiator = false;
        this.streamStartTime = null;
        this.reconnectAttempts = 0;
        this.isStreamingActive = false;
        this.connectionState = 'disconnected';
        
        console.log('✅ Viewer completely disconnected and cleaned up');
    },

    // Enhanced close (for streamer)
    close: async function() {
        console.log('🔌 Closing streamer...');
        
        if (this.peerConnection) {
            this.peerConnection.close();
            this.peerConnection = null;
        }
        
        if (this.pollingInterval) {
            clearInterval(this.pollingInterval);
        }
        
        this.stopConnectionMetrics();
        
        this.sessionId = null;
        this.isInitiator = false;
        this.currentCameraId = null;
        this.streamStartTime = null;
        this.isStreamingActive = false;
        this.reconnectAttempts = 0;
        this.connectionState = 'disconnected';
        
        // Update UI
        document.getElementById('streaming-role').textContent = 'Not Connected';
        document.getElementById('streaming-role').style.background = 'rgba(0,0,0,0.7)';
        
        console.log('✅ Streamer completely disconnected and cleaned up');
    },

    // Update viewer count display
    updateViewerCount: async function(count) {
        if (this.isInitiator) {
            try {
                const stats = await API.getWebRTCSessionStats(this.sessionId);
                if (stats.success) {
                    const viewerCount = stats.stats.viewerCount || 0;
                    document.getElementById('stream-devices').textContent = 
                        `${viewerCount} viewer(s) connected`;
                }
            } catch (error) {
                console.error('Error getting viewer count:', error);
            }
        }
    },

    // Enhanced connection failure handling
    handleConnectionFailure: function() {
        this.stopConnectionMetrics();
        
        // Auto-reconnect for viewers
        if (!this.isInitiator && this.isStreamingActive) {
            this.reconnectAttempts++;
            if (this.reconnectAttempts <= this.maxReconnectAttempts) {
                console.log(`🔄 Reconnection attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
                setTimeout(() => {
                    this.reconnectAsViewer();
                }, 2000 * this.reconnectAttempts);
            } else {
                console.log('❌ Max reconnection attempts reached');
                this.updateViewerUI('Failed to reconnect after multiple attempts');
            }
        }
    },

    // Enhanced reconnect as viewer
    reconnectAsViewer: async function() {
        if (!this.sessionId) return;
        
        console.log(`🔄 Reconnecting as viewer to session: ${this.sessionId}`);
        
        try {
            // Clean up existing connection
            if (this.peerConnection) {
                this.peerConnection.close();
                this.peerConnection = null;
            }

            // Reinitialize and reconnect
            await this.initWebRTC(false);
            this.startPollingForOffer();
            
            this.updateViewerUI(`Reconnecting... (Attempt ${this.reconnectAttempts})`);
        } catch (error) {
            console.error('❌ Error during reconnection:', error);
        }
    },

    // Update streamer UI
    updateStreamerUI: function() {
        document.getElementById('streaming-role').textContent = 'STREAMING';
        document.getElementById('streaming-role').style.background = 'var(--success)';
        document.getElementById('stream-role-info').textContent = 'Streaming to other devices';
        document.getElementById('stream-status').textContent = 'Streaming active';
        document.getElementById('stream-devices').textContent = '0 viewers connected';
    },

    // Update viewer UI
    updateViewerUI: function(status) {
        document.getElementById('streaming-role').textContent = 'VIEWING';
        document.getElementById('streaming-role').style.background = 'var(--secondary)';
        document.getElementById('stream-role-info').textContent = 'Viewing remote stream';
        document.getElementById('placeholder-text').textContent = status;
        document.getElementById('stream-status').textContent = status;
        
        // Hide streamer controls for viewer
        document.getElementById('start-live-camera').classList.add('hidden');
        document.getElementById('stop-live-camera').classList.add('hidden');
    },

    // Start connection metrics
    startConnectionMetrics: function() {
        const updateMetrics = () => {
            if (this.streamStartTime) {
                const now = new Date();
                const uptime = Math.floor((now - this.streamStartTime) / 1000);
                const minutes = Math.floor(uptime / 60);
                const seconds = uptime % 60;
                
                document.getElementById('stream-uptime').textContent = 
                    `Uptime: ${minutes}m ${seconds}s`;
                
                // Simulate latency for demo
                const latency = Math.floor(50 + Math.random() * 100);
                document.getElementById('stream-latency').textContent = latency;
            }
        };
        
        this.metricsInterval = setInterval(updateMetrics, 2000);
        updateMetrics();
    },

    // Stop connection metrics
    stopConnectionMetrics: function() {
        if (this.metricsInterval) {
            clearInterval(this.metricsInterval);
        }
    }
};
            
            showStreamingAlert(message, type = 'error') {
                elements.streamingAlert.textContent = message;
                elements.streamingAlert.className = `alert alert-${type}`;
                elements.streamingAlert.classList.remove('hidden');
                
                setTimeout(() => {
                    elements.streamingAlert.classList.add('hidden');
                }, 5000);
            }
        };

        // App management
        const AppManager = {
            async init() {
                await this.loadCameras();
                await this.loadEvents();
                await this.loadActiveStreams();
                this.setupEventListeners();
            },
            
            async loadCameras() {
                try {
                    const result = await API.getCameras();
                    cameras = result.cameras;
                    this.renderCameras();
                } catch (error) {
                    this.showCamerasAlert(`Failed to load cameras: ${error.message}`, 'error');
                }
            },
            
            async loadEvents() {
                try {
                    const result = await API.getEvents();
                    events = result.events;
                    this.renderEvents();
                } catch (error) {
                    console.error('Failed to load events:', error);
                }
            },
            
            async loadActiveStreams() {
                try {
                    const result = await API.getStreams();
                    activeStreams = result.streams;
                    this.renderStreamSelector();
                } catch (error) {
                    console.error('Failed to load active streams:', error);
                }
            },
            
            renderCameras() {
                elements.camerasGrid.innerHTML = '';
                
                if (cameras.length === 0) {
                    elements.camerasGrid.innerHTML = `
                        <div style="grid-column: 1 / -1; text-align: center; padding: 2rem; color: var(--gray-600);">
                            No cameras yet. Click "Add Camera" to get started.
                        </div>
                    `;
                    return;
                }
                
                cameras.forEach(camera => {
                    const card = document.createElement('div');
                    card.className = 'camera-card';
                    card.innerHTML = `
                        <div class="camera-header">
                            <div>
                                <div class="camera-name">${camera.name}</div>
                                <div class="camera-location">${camera.location}</div>
                            </div>
                            <span class="camera-status status-${camera.status}">
                                ${camera.status === 'streaming' ? '● Streaming' : '● Offline'}
                            </span>
                        </div>
                        <div class="camera-info">
                            <div style="font-size: 0.875rem; color: var(--gray-600);">
                                Quality: ${camera.quality} | ID: ${camera.id}
                            </div>
                        </div>
                        <div class="camera-actions">
                            <button class="btn btn-primary btn-sm" onclick="AppManager.startCameraStream('${camera.id}', '${camera.name}')">
                                Start Stream
                            </button>
                            <button class="btn btn-outline btn-sm" onclick="AppManager.deleteCamera('${camera.id}')">
                                Delete
                            </button>
                        </div>
                    `;
                    elements.camerasGrid.appendChild(card);
                });
            },
            
            renderEvents() {
                elements.eventsList.innerHTML = '';
                
                if (events.length === 0) {
                    elements.eventsList.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: var(--gray-600);">
                            No events yet.
                        </div>
                    `;
                    return;
                }
                
                events.slice(0, 10).forEach(event => {
                    const eventItem = document.createElement('div');
                    eventItem.className = 'event-item';
                    
                    const typeClass = event.type.includes('error') ? 'type-warning' : 
                                    event.type.includes('success') ? 'type-success' : 'type-info';
                    
                    eventItem.innerHTML = `
                        <div>
                            <div style="font-weight: 500;">${event.description}</div>
                            <div style="font-size: 0.875rem; color: var(--gray-600);">
                                ${new Date(event.timestamp).toLocaleString()}
                            </div>
                        </div>
                        <span class="event-type ${typeClass}">${event.type}</span>
                    `;
                    elements.eventsList.appendChild(eventItem);
                });
            },
            
            renderStreamSelector() {
                elements.streamSelector.innerHTML = '<option value="">Select a stream...</option>';
                
                activeStreams.forEach(stream => {
                    const option = document.createElement('option');
                    option.value = stream.id;
                    option.textContent = `${stream.cameraName} (${stream.id})`;
                    elements.streamSelector.appendChild(option);
                });
            },
            
            async startCameraStream(cameraId, cameraName) {
                await WebRTCManager.startStreaming(cameraId, cameraName);
            },
            
            async deleteCamera(cameraId) {
                if (!confirm('Are you sure you want to delete this camera?')) {
                    return;
                }
                
                try {
                    await API.deleteCamera(cameraId);
                    this.showCamerasAlert('Camera deleted successfully', 'success');
                    await this.loadCameras();
                } catch (error) {
                    this.showCamerasAlert(`Failed to delete camera: ${error.message}`, 'error');
                }
            },
            
            async createCamera(cameraData) {
                try {
                    await API.createCamera(cameraData);
                    this.hideCameraModal();
                    this.showCamerasAlert('Camera created successfully', 'success');
                    await this.loadCameras();
                } catch (error) {
                    this.showCamerasAlert(`Failed to create camera: ${error.message}`, 'error');
                }
            },
            
            showCameraModal() {
                elements.cameraModal.classList.remove('hidden');
            },
            
            hideCameraModal() {
                elements.cameraModal.classList.add('hidden');
                elements.cameraForm.reset();
            },
            
            showCamerasAlert(message, type = 'error') {
                elements.camerasAlert.textContent = message;
                elements.camerasAlert.className = `alert alert-${type}`;
                elements.camerasAlert.classList.remove('hidden');
                
                setTimeout(() => {
                    elements.camerasAlert.classList.add('hidden');
                }, 5000);
            },
            
            setupEventListeners() {
                // Camera form
                elements.cameraForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const formData = new FormData(e.target);
                    const cameraData = {
                        name: formData.get('name'),
                        location: formData.get('location'),
                        quality: formData.get('quality')
                    };
                    this.createCamera(cameraData);
                });
                
                // Stream controls
                elements.startStreamBtn.addEventListener('click', () => {
                    if (cameras.length === 0) {
                                        this.showCamerasAlert('Please create a camera first', 'error');
                                        return;
                                    }
                                    // Use the first camera for demo purposes
                                    const camera = cameras[0];
                                    this.startCameraStream(camera.id, camera.name);
                                });
                
                elements.stopStreamBtn.addEventListener('click', () => {
                    WebRTCManager.stopStreaming();
                });
                
                elements.startViewerBtn.addEventListener('click', () => {
                    const streamId = elements.streamSelector.value;
                    if (!streamId) {
                        WebRTCManager.showStreamingAlert('Please select a stream', 'error');
                        return;
                    }
                    WebRTCManager.startViewer(streamId);
                });
                
                elements.stopViewerBtn.addEventListener('click', () => {
                    WebRTCManager.disconnectViewer();
                });
                
                elements.refreshCamerasBtn.addEventListener('click', () => {
                    this.loadCameras();
                    this.loadActiveStreams();
                });
                
                elements.refreshEventsBtn.addEventListener('click', () => {
                    this.loadEvents();
                });
                
                elements.cancelCameraBtn.addEventListener('click', () => {
                    this.hideCameraModal();
                });
            }
        };

        // Auth form handling
        let isLoginMode = true;
        
        function switchAuthMode() {
            isLoginMode = !isLoginMode;
            
            elements.authTitle.textContent = isLoginMode ? 'Login' : 'Register';
            elements.authSubmitText.textContent = isLoginMode ? 'Login' : 'Register';
            elements.authSwitch.textContent = isLoginMode ? 'Switch to Register' : 'Switch to Login';
            elements.nameGroup.classList.toggle('hidden', isLoginMode);
        }
        
        async function handleAuthSubmit(e) {
            e.preventDefault();
            
            const formData = new FormData(e.target);
            const authData = {
                email: formData.get('email'),
                password: formData.get('password')
            };
            
            if (!isLoginMode) {
                authData.name = formData.get('name');
            }
            
            try {
                elements.authSubmit.disabled = true;
                elements.authSubmit.classList.add('loading');
                
                if (isLoginMode) {
                    await AuthManager.login(authData);
                } else {
                    await AuthManager.register(authData);
                }
                
                e.target.reset();
            } catch (error) {
                // Error handled in AuthManager
            } finally {
                elements.authSubmit.disabled = false;
                elements.authSubmit.classList.remove('loading');
            }
        }

        // Initialize app
        document.addEventListener('DOMContentLoaded', () => {
            // Set up auth event listeners
            elements.authForm.addEventListener('submit', handleAuthSubmit);
            elements.authSwitch.addEventListener('click', switchAuthMode);
            elements.logoutBtn.addEventListener('click', () => AuthManager.logout());
            elements.addCameraBtn.addEventListener('click', () => AppManager.showCameraModal());
            
            // Check if user is already logged in
            if (AuthManager.loadFromStorage()) {
                console.log('User loaded from storage');
            }
        });

        // Make managers globally available for onclick handlers
        window.AppManager = AppManager;
        window.WebRTCManager = WebRTCManager;
    </script>
</body>
</html>
