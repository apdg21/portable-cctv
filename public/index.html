<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SecureCam - Secure Video Surveillance</title>
    <style>
        :root {
            --primary-color: #2563eb;
            --primary-dark: #1d4ed8;
            --danger-color: #dc2626;
            --success-color: #16a34a;
            --warning-color: #d97706;
            --gray-100: #f3f4f6;
            --gray-200: #e5e7eb;
            --gray-300: #d1d5db;
            --gray-600: #4b5563;
            --gray-700: #374151;
            --gray-800: #1f2937;
            --gray-900: #111827;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--gray-100);
            color: var(--gray-900);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        header {
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
        }
        
        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-color);
        }
        
        .nav-buttons {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 0.375rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }
        
        .btn-primary:hover {
            background-color: var(--primary-dark);
        }
        
        .btn-danger {
            background-color: var(--danger-color);
            color: white;
        }
        
        .btn-danger:hover {
            background-color: #b91c1c;
        }
        
        .btn-success {
            background-color: var(--success-color);
            color: white;
        }
        
        .btn-success:hover {
            background-color: #15803d;
        }
        
        .btn-outline {
            background-color: transparent;
            border: 1px solid var(--gray-300);
            color: var(--gray-700);
        }
        
        .btn-outline:hover {
            background-color: var(--gray-100);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        main {
            padding: 2rem 0;
        }
        
        .section {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--gray-900);
        }
        
        .auth-section {
            max-width: 400px;
            margin: 2rem auto;
        }
        
        .form-group {
            margin-bottom: 1rem;
        }
        
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--gray-700);
        }
        
        input, select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--gray-300);
            border-radius: 0.375rem;
            font-size: 1rem;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }
        
        .form-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        
        .cameras-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
        }
        
        .camera-card {
            border: 1px solid var(--gray-200);
            border-radius: 0.5rem;
            padding: 1.5rem;
            background: white;
        }
        
        .camera-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 1rem;
        }
        
        .camera-name {
            font-weight: 600;
            font-size: 1.125rem;
            color: var(--gray-900);
        }
        
        .camera-location {
            color: var(--gray-600);
            margin-bottom: 0.5rem;
        }
        
        .camera-status {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 500;
        }
        
        .status-online {
            background-color: #dcfce7;
            color: #166534;
        }
        
        .status-offline {
            background-color: #f3f4f6;
            color: var(--gray-600);
        }
        
        .status-streaming {
            background-color: #dbeafe;
            color: var(--primary-dark);
        }
        
        .camera-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        
        .streaming-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }
        
        .video-container {
            position: relative;
            background: var(--gray-900);
            border-radius: 0.5rem;
            overflow: hidden;
            aspect-ratio: 16/9;
        }
        
        .video-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--gray-400);
            background: var(--gray-800);
        }
        
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .stream-controls {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .stream-info {
            background: var(--gray-50);
            padding: 1rem;
            border-radius: 0.375rem;
            margin-top: 1rem;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }
        
        .info-item {
            display: flex;
            flex-direction: column;
        }
        
        .info-label {
            font-size: 0.875rem;
            color: var(--gray-600);
        }
        
        .info-value {
            font-weight: 600;
            color: var(--gray-900);
        }
        
        .events-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .event-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            border-bottom: 1px solid var(--gray-200);
        }
        
        .event-item:last-child {
            border-bottom: none;
        }
        
        .event-type {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
        }
        
        .type-info {
            background-color: #dbeafe;
            color: var(--primary-dark);
        }
        
        .type-warning {
            background-color: #fef3c7;
            color: var(--warning-color);
        }
        
        .type-success {
            background-color: #dcfce7;
            color: var(--success-color);
        }
        
        .alert {
            padding: 1rem;
            border-radius: 0.375rem;
            margin-bottom: 1rem;
        }
        
        .alert-error {
            background-color: #fef2f2;
            border: 1px solid #fecaca;
            color: var(--danger-color);
        }
        
        .alert-success {
            background-color: #f0fdf4;
            border: 1px solid #bbf7d0;
            color: var(--success-color);
        }
        
        .alert-info {
            background-color: #eff6ff;
            border: 1px solid #dbeafe;
            color: var(--primary-color);
        }
        
        .hidden {
            display: none !important;
        }
        
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
        
        .metrics-panel {
            background: var(--gray-50);
            padding: 1rem;
            border-radius: 0.375rem;
            margin-top: 1rem;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
        }
        
        .metric-item {
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-color);
        }
        
        .metric-label {
            font-size: 0.875rem;
            color: var(--gray-600);
        }
        
        @media (max-width: 768px) {
            .streaming-section {
                grid-template-columns: 1fr;
            }
            
            .cameras-grid {
                grid-template-columns: 1fr;
            }
            
            .header-content {
                flex-direction: column;
                gap: 1rem;
            }
            
            .nav-buttons {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo">SecureCam</div>
                <div class="nav-buttons">
                    <button id="loginBtn" class="btn btn-outline">Login</button>
                    <button id="registerBtn" class="btn btn-outline">Register</button>
                    <button id="logoutBtn" class="btn btn-outline hidden">Logout</button>
                </div>
            </div>
        </div>
    </header>

    <main class="container">
        <!-- Auth Section -->
        <section id="authSection" class="section auth-section">
            <div class="section-header">
                <h2 class="section-title" id="authTitle">Login</h2>
            </div>
            
            <div id="authAlert" class="alert hidden"></div>
            
            <form id="authForm">
                <div class="form-group" id="nameGroup">
                    <label for="name">Full Name</label>
                    <input type="text" id="name" name="name" required>
                </div>
                
                <div class="form-group">
                    <label for="email">Email</label>
                    <input type="email" id="email" name="email" required>
                </div>
                
                <div class="form-group">
                    <label for="password">Password</label>
                    <input type="password" id="password" name="password" required minlength="6">
                </div>
                
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary" id="authSubmit">
                        <span id="authSubmitText">Login</span>
                    </button>
                    <button type="button" class="btn btn-outline" id="authSwitch">
                        Switch to Register
                    </button>
                </div>
            </form>
        </section>

        <!-- Main App Section -->
        <section id="appSection" class="hidden">
            <!-- Cameras Section -->
            <section class="section">
                <div class="section-header">
                    <h2 class="section-title">My Cameras</h2>
                    <button id="addCameraBtn" class="btn btn-primary">Add Camera</button>
                </div>
                
                <div id="camerasAlert" class="alert hidden"></div>
                
                <div class="cameras-grid" id="camerasGrid">
                    <!-- Camera cards will be populated here -->
                </div>
            </section>

            <!-- Streaming Section -->
            <section class="section">
                <div class="section-header">
                    <h2 class="section-title">Live Streaming</h2>
                </div>
                
                <div id="streamingAlert" class="alert hidden"></div>
                
                <div class="streaming-section">
                    <!-- Streamer Side -->
                    <div>
                        <h3>Camera Stream</h3>
                        <div class="video-container">
                            <video id="localVideo" autoplay muted playsinline></video>
                            <div id="localVideoPlaceholder" class="video-placeholder">
                                Camera feed will appear here
                            </div>
                        </div>
                        
                        <div class="stream-controls">
                            <button id="startStreamBtn" class="btn btn-success">Start Streaming</button>
                            <button id="stopStreamBtn" class="btn btn-danger hidden">Stop Streaming</button>
                            <button id="refreshCamerasBtn" class="btn btn-outline">Refresh Cameras</button>
                        </div>
                        
                        <div id="streamerInfo" class="stream-info hidden">
                            <div class="info-grid">
                                <div class="info-item">
                                    <span class="info-label">Stream ID</span>
                                    <span class="info-value" id="streamIdValue">-</span>
                                </div>
                                <div class="info-item">
                                    <span class="info-label">Status</span>
                                    <span class="info-value" id="streamStatus">-</span>
                                </div>
                                <div class="info-item">
                                    <span class="info-label">Viewers</span>
                                    <span class="info-value" id="viewerCount">0</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Viewer Side -->
                    <div>
                        <h3>Viewer Stream</h3>
                        <div class="video-container">
                            <video id="remoteVideo" autoplay playsinline></video>
                            <div id="remoteVideoPlaceholder" class="video-placeholder">
                                Remote stream will appear here
                            </div>
                        </div>
                        
                        <div class="stream-controls">
                            <button id="startViewerBtn" class="btn btn-primary">Start Viewer</button>
                            <button id="stopViewerBtn" class="btn btn-danger hidden">Stop Viewer</button>
                            <select id="streamSelector">
                                <option value="">Select a stream...</option>
                            </select>
                        </div>
                        
                        <div id="viewerInfo" class="stream-info hidden">
                            <div class="info-grid">
                                <div class="info-item">
                                    <span class="info-label">Connection</span>
                                    <span class="info-value" id="connectionStatus">Disconnected</span>
                                </div>
                                <div class="info-item">
                                    <span class="info-label">Stream Quality</span>
                                    <span class="info-value" id="streamQuality">-</span>
                                </div>
                                <div class="info-item">
                                    <span class="info-label">Latency</span>
                                    <span class="info-value" id="streamLatency">-</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Connection Metrics -->
                <div id="metricsPanel" class="metrics-panel hidden">
                    <h4>Connection Metrics</h4>
                    <div class="metrics-grid">
                        <div class="metric-item">
                            <div class="metric-value" id="metricBitrate">0</div>
                            <div class="metric-label">Bitrate (kbps)</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value" id="metricPackets">0</div>
                            <div class="metric-label">Packets/s</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value" id="metricJitter">0</div>
                            <div class="metric-label">Jitter (ms)</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value" id="metricRtt">0</div>
                            <div class="metric-label">RTT (ms)</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Events Section -->
            <section class="section">
                <div class="section-header">
                    <h2 class="section-title">Recent Events</h2>
                    <button id="refreshEventsBtn" class="btn btn-outline">Refresh</button>
                </div>
                
                <div class="events-list" id="eventsList">
                    <!-- Events will be populated here -->
                </div>
            </section>
        </section>
    </main>

    <!-- Add Camera Modal -->
    <div id="cameraModal" class="modal hidden" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000;">
        <div style="background: white; padding: 2rem; border-radius: 0.5rem; width: 90%; max-width: 400px;">
            <h3 style="margin-bottom: 1rem;">Add New Camera</h3>
            <form id="cameraForm">
                <div class="form-group">
                    <label for="cameraName">Camera Name</label>
                    <input type="text" id="cameraName" name="name" required>
                </div>
                
                <div class="form-group">
                    <label for="cameraLocation">Location</label>
                    <input type="text" id="cameraLocation" name="location" required>
                </div>
                
                <div class="form-group">
                    <label for="cameraQuality">Stream Quality</label>
                    <select id="cameraQuality" name="quality">
                        <option value="low">Low (480p)</option>
                        <option value="medium" selected>Medium (720p)</option>
                        <option value="high">High (1080p)</option>
                    </select>
                </div>
                
                <div class="form-actions">
                    <button type="submit" class="btn btn-primary">Add Camera</button>
                    <button type="button" class="btn btn-outline" id="cancelCameraBtn">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // API configuration
        const API_BASE_URL = window.location.origin;
        
        // Global state
        let authToken = null;
        let currentUser = null;
        let cameras = [];
        let activeStreams = [];
        let events = [];
        
        // WebRTC state
        let peerConnection = null;
        let localStream = null;
        let currentSessionId = null;
        let isInitiator = false;
        let pollingInterval = null;
        let metricsInterval = null;
        let streamStartTime = null;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;
        
        // DOM elements
        const elements = {
            // Auth
            authSection: document.getElementById('authSection'),
            appSection: document.getElementById('appSection'),
            authTitle: document.getElementById('authTitle'),
            authForm: document.getElementById('authForm'),
            authAlert: document.getElementById('authAlert'),
            authSubmit: document.getElementById('authSubmit'),
            authSubmitText: document.getElementById('authSubmitText'),
            authSwitch: document.getElementById('authSwitch'),
            nameGroup: document.getElementById('nameGroup'),
            loginBtn: document.getElementById('loginBtn'),
            registerBtn: document.getElementById('registerBtn'),
            logoutBtn: document.getElementById('logoutBtn'),
            
            // Cameras
            camerasGrid: document.getElementById('camerasGrid'),
            camerasAlert: document.getElementById('camerasAlert'),
            addCameraBtn: document.getElementById('addCameraBtn'),
            cameraModal: document.getElementById('cameraModal'),
            cameraForm: document.getElementById('cameraForm'),
            cancelCameraBtn: document.getElementById('cancelCameraBtn'),
            refreshCamerasBtn: document.getElementById('refreshCamerasBtn'),
            
            // Streaming
            localVideo: document.getElementById('localVideo'),
            localVideoPlaceholder: document.getElementById('localVideoPlaceholder'),
            remoteVideo: document.getElementById('remoteVideo'),
            remoteVideoPlaceholder: document.getElementById('remoteVideoPlaceholder'),
            startStreamBtn: document.getElementById('startStreamBtn'),
            stopStreamBtn: document.getElementById('stopStreamBtn'),
            startViewerBtn: document.getElementById('startViewerBtn'),
            stopViewerBtn: document.getElementById('stopViewerBtn'),
            streamSelector: document.getElementById('streamSelector'),
            streamingAlert: document.getElementById('streamingAlert'),
            streamerInfo: document.getElementById('streamerInfo'),
            viewerInfo: document.getElementById('viewerInfo'),
            streamIdValue: document.getElementById('streamIdValue'),
            streamStatus: document.getElementById('streamStatus'),
            viewerCount: document.getElementById('viewerCount'),
            connectionStatus: document.getElementById('connectionStatus'),
            streamQuality: document.getElementById('streamQuality'),
            streamLatency: document.getElementById('streamLatency'),
            
            // Metrics
            metricsPanel: document.getElementById('metricsPanel'),
            metricBitrate: document.getElementById('metricBitrate'),
            metricPackets: document.getElementById('metricPackets'),
            metricJitter: document.getElementById('metricJitter'),
            metricRtt: document.getElementById('metricRtt'),
            
            // Events
            eventsList: document.getElementById('eventsList'),
            refreshEventsBtn: document.getElementById('refreshEventsBtn')
        };

        // API service
        const API = {
            async request(endpoint, options = {}) {
                const url = `${API_BASE_URL}${endpoint}`;
                const config = {
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    },
                    ...options
                };
                
                if (authToken) {
                    config.headers.Authorization = `Bearer ${authToken}`;
                }
                
                try {
                    const response = await fetch(url, config);
                    const data = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(data.error || `HTTP ${response.status}`);
                    }
                    
                    return data;
                } catch (error) {
                    console.error(`API request failed: ${endpoint}`, error);
                    throw error;
                }
            },
            
            // Auth
            async register(userData) {
                return this.request('/api/register', {
                    method: 'POST',
                    body: JSON.stringify(userData)
                });
            },
            
            async login(credentials) {
                return this.request('/api/login', {
                    method: 'POST',
                    body: JSON.stringify(credentials)
                });
            },
            
            // Cameras
            async getCameras() {
                return this.request('/api/cameras');
            },
            
            async createCamera(cameraData) {
                return this.request('/api/cameras', {
                    method: 'POST',
                    body: JSON.stringify(cameraData)
                });
            },
            
            async deleteCamera(cameraId) {
                return this.request(`/api/cameras/${cameraId}/delete`, {
                    method: 'POST'
                });
            },
            
            // Streams
            async startStream(streamData) {
                return this.request('/api/streams/start', {
                    method: 'POST',
                    body: JSON.stringify(streamData)
                });
            },
            
            async stopStream(streamId) {
                return this.request(`/api/streams/${streamId}/stop`, {
                    method: 'POST'
                });
            },
            
            async getStreams() {
                return this.request('/api/streams');
            },
            
            async getStream(streamId) {
                return this.request(`/api/streams/${streamId}`);
            },
            
            // WebRTC
            async createWebRTCSession(sessionData) {
                return this.request('/api/webrtc/session', {
                    method: 'POST',
                    body: JSON.stringify(sessionData)
                });
            },
            
            async getWebRTCSession(streamId) {
                return this.request(`/api/webrtc/session/${streamId}`);
            },
            
            async pollWebRTCSession(streamId) {
                return this.request(`/api/webrtc/session/${streamId}/poll`);
            },
            
            async sendOffer(sessionId, offer) {
                return this.request(`/api/webrtc/session/${sessionId}/offer`, {
                    method: 'POST',
                    body: JSON.stringify({ offer })
                });
            },
            
            async sendAnswer(sessionId, answer) {
                return this.request(`/api/webrtc/session/${sessionId}/answer`, {
                    method: 'POST',
                    body: JSON.stringify({ answer })
                });
            },
            
            async sendCandidate(sessionId, candidate) {
                return this.request(`/api/webrtc/session/${sessionId}/candidate`, {
                    method: 'POST',
                    body: JSON.stringify({ candidate })
                });
            },
            
            async leaveWebRTCSession(sessionId) {
                return this.request(`/api/webrtc/session/${sessionId}/leave`, {
                    method: 'POST'
                });
            },
            
            // Events
            async getEvents() {
                return this.request('/api/events');
            }
        };

        // Auth management
        const AuthManager = {
            isLoggedIn() {
                return !!authToken;
            },
            
            async login(credentials) {
                try {
                    const result = await API.login(credentials);
                    this.setAuth(result.token, result.user);
                    this.showAlert('Login successful!', 'success');
                    return result;
                } catch (error) {
                    this.showAlert(error.message, 'error');
                    throw error;
                }
            },
            
            async register(userData) {
                try {
                    const result = await API.register(userData);
                    this.setAuth(result.token, result.user);
                    this.showAlert('Registration successful!', 'success');
                    return result;
                } catch (error) {
                    this.showAlert(error.message, 'error');
                    throw error;
                }
            },
            
            logout() {
                authToken = null;
                currentUser = null;
                localStorage.removeItem('authToken');
                localStorage.removeItem('user');
                this.updateUI();
                this.showAlert('Logged out successfully', 'success');
            },
            
            setAuth(token, user) {
                authToken = token;
                currentUser = user;
                localStorage.setItem('authToken', token);
                localStorage.setItem('user', JSON.stringify(user));
                this.updateUI();
            },
            
            loadFromStorage() {
                const token = localStorage.getItem('authToken');
                const user = localStorage.getItem('user');
                
                if (token && user) {
                    authToken = token;
                    currentUser = JSON.parse(user);
                    this.updateUI();
                    return true;
                }
                return false;
            },
            
            updateUI() {
                const isAuthenticated = this.isLoggedIn();
                
                elements.authSection.classList.toggle('hidden', isAuthenticated);
                elements.appSection.classList.toggle('hidden', !isAuthenticated);
                elements.loginBtn.classList.toggle('hidden', isAuthenticated);
                elements.registerBtn.classList.toggle('hidden', isAuthenticated);
                elements.logoutBtn.classList.toggle('hidden', !isAuthenticated);
                
                if (isAuthenticated) {
                    AppManager.init();
                } else {
                    WebRTCManager.disconnectViewer();
                    WebRTCManager.stopStreaming();
                }
            },
            
            showAlert(message, type = 'error') {
                elements.authAlert.textContent = message;
                elements.authAlert.className = `alert alert-${type}`;
                elements.authAlert.classList.remove('hidden');
                
                setTimeout(() => {
                    elements.authAlert.classList.add('hidden');
                }, 5000);
            }
        };

        // WebRTC management
        const WebRTCManager = {
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            },
            
            constraints: {
                video: {
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    frameRate: { ideal: 30 }
                },
                audio: false
            },
            
            // Streamer functions
            async startStreaming(cameraId, cameraName) {
                try {
                    this.showStreamingAlert('Starting WebRTC stream...', 'info');
                    
                    // Get camera stream
                    localStream = await navigator.mediaDevices.getUserMedia(this.constraints);
                    elements.localVideo.srcObject = localStream;
                    elements.localVideoPlaceholder.classList.add('hidden');
                    
                    // Create WebRTC session
                    const sessionResult = await API.createWebRTCSession({
                        cameraId,
                        cameraName
                    });
                    
                    currentSessionId = sessionResult.sessionId;
                    isInitiator = true;
                    streamStartTime = Date.now();
                    
                    // Create peer connection
                    await this.createPeerConnection();
                    
                    // Add local stream to connection
                    localStream.getTracks().forEach(track => {
                        peerConnection.addTrack(track, localStream);
                    });
                    
                    // Create and send offer
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    await API.sendOffer(currentSessionId, offer);
                    
                    // Start polling for answers and candidates
                    this.startPolling();
                    
                    // Update UI
                    elements.startStreamBtn.classList.add('hidden');
                    elements.stopStreamBtn.classList.remove('hidden');
                    elements.streamerInfo.classList.remove('hidden');
                    elements.streamIdValue.textContent = currentSessionId;
                    elements.streamStatus.textContent = 'Streaming';
                    
                    this.showStreamingAlert('WebRTC stream started successfully!', 'success');
                    this.startConnectionMetrics();
                    
                } catch (error) {
                    console.error('Error starting stream:', error);
                    this.showStreamingAlert(`Failed to start stream: ${error.message}`, 'error');
                    this.cleanupStreaming();
                }
            },
            
            async stopStreaming() {
                try {
                    if (currentSessionId && isInitiator) {
                        await API.stopStream(currentSessionId);
                    }
                } catch (error) {
                    console.log('Note: Could not notify backend of stream stop', error.message);
                }
                
                this.cleanupStreaming();
                this.showStreamingAlert('Stream stopped', 'info');
            },
            
            cleanupStreaming() {
                // Stop local stream
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
                
                // Clean up peer connection
                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
                
                // Stop polling and metrics
                this.stopPolling();
                this.stopConnectionMetrics();
                
                // Reset UI
                elements.localVideo.srcObject = null;
                elements.localVideoPlaceholder.classList.remove('hidden');
                elements.startStreamBtn.classList.remove('hidden');
                elements.stopStreamBtn.classList.add('hidden');
                elements.streamerInfo.classList.add('hidden');
                elements.metricsPanel.classList.add('hidden');
                
                currentSessionId = null;
                isInitiator = false;
                streamStartTime = null;
                reconnectAttempts = 0;
            },
            
            // Viewer functions
            async startViewer(streamId) {
                try {
                    this.showStreamingAlert('Connecting to WebRTC stream...', 'info');
                    
                    currentSessionId = streamId;
                    isInitiator = false;
                    
                    // Create peer connection
                    await this.createPeerConnection();
                    
                    // Start polling for offer
                    this.startPolling();
                    
                    // Update UI
                    elements.startViewerBtn.classList.add('hidden');
                    elements.stopViewerBtn.classList.remove('hidden');
                    elements.viewerInfo.classList.remove('hidden');
                    elements.connectionStatus.textContent = 'Connecting...';
                    
                } catch (error) {
                    console.error('Error starting viewer:', error);
                    this.showStreamingAlert(`Failed to connect: ${error.message}`, 'error');
                    this.disconnectViewer();
                }
            },
            
            // Enhanced disconnect with better cleanup
            async disconnectViewer() {
                // Notify backend that viewer is leaving
                if (currentSessionId && authToken) {
                    try {
                        await API.leaveWebRTCSession(currentSessionId);
                        console.log('✅ Notified backend of viewer departure');
                    } catch (error) {
                        console.log('Note: Could not notify backend of departure', error.message);
                    }
                }

                // Clean up WebRTC connection
                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
                
                // Stop polling
                if (pollingInterval) {
                    clearInterval(pollingInterval);
                }
                
                // Stop metrics
                this.stopConnectionMetrics();
                
                // Reset state
                currentSessionId = null;
                isInitiator = false;
                streamStartTime = null;
                reconnectAttempts = 0;
                
                // Reset UI
                elements.remoteVideo.srcObject = null;
                elements.remoteVideoPlaceholder.classList.remove('hidden');
                elements.startViewerBtn.classList.remove('hidden');
                elements.stopViewerBtn.classList.add('hidden');
                elements.viewerInfo.classList.add('hidden');
                elements.metricsPanel.classList.add('hidden');
                elements.connectionStatus.textContent = 'Disconnected';
                
                console.log('✅ Viewer completely disconnected and cleaned up');
            },
            
            // WebRTC connection management
            async createPeerConnection() {
                peerConnection = new RTCPeerConnection(this.config);
                
                // Handle incoming tracks (for viewer)
                peerConnection.ontrack = (event) => {
                    console.log('Received remote stream');
                    elements.remoteVideo.srcObject = event.streams[0];
                    elements.remoteVideoPlaceholder.classList.add('hidden');
                    elements.connectionStatus.textContent = 'Connected';
                    this.showStreamingAlert('Successfully connected to stream!', 'success');
                };
                
                // Handle ICE candidates
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate && currentSessionId) {
                        API.sendCandidate(currentSessionId, event.candidate)
                            .catch(error => console.error('Error sending candidate:', error));
                    }
                };
                
                // Handle connection state changes
                peerConnection.onconnectionstatechange = () => {
                    console.log('Connection state:', peerConnection.connectionState);
                    elements.connectionStatus.textContent = peerConnection.connectionState;
                    
                    if (peerConnection.connectionState === 'connected') {
                        this.showStreamingAlert('WebRTC connection established!', 'success');
                        reconnectAttempts = 0;
                    } else if (peerConnection.connectionState === 'failed' || 
                              peerConnection.connectionState === 'disconnected') {
                        this.handleReconnection();
                    }
                };
                
                // Handle ICE connection state
                peerConnection.oniceconnectionstatechange = () => {
                    console.log('ICE connection state:', peerConnection.iceConnectionState);
                    
                    if (peerConnection.iceConnectionState === 'failed') {
                        this.handleReconnection();
                    }
                };
            },
            
            async handleReconnection() {
                if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                    this.showStreamingAlert('Failed to reconnect after multiple attempts', 'error');
                    if (isInitiator) {
                        this.stopStreaming();
                    } else {
                        this.disconnectViewer();
                    }
                    return;
                }
                
                reconnectAttempts++;
                this.showStreamingAlert(`Attempting to reconnect... (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`, 'warning');
                
                // For viewer, try to reconnect by restarting the viewer
                if (!isInitiator && currentSessionId) {
                    setTimeout(() => {
                        this.disconnectViewer();
                        this.startViewer(currentSessionId);
                    }, 2000 * reconnectAttempts);
                }
            },
            
            // Polling for WebRTC signaling
            startPolling() {
                if (pollingInterval) {
                    clearInterval(pollingInterval);
                }
                
                pollingInterval = setInterval(async () => {
                    if (!currentSessionId) return;
                    
                    try {
                        const sessionData = await API.pollWebRTCSession(currentSessionId);
                        
                        if (isInitiator) {
                            // Streamer: check for answers and update viewer count
                            if (sessionData.hasAnswer) {
                                const fullSession = await API.getWebRTCSession(currentSessionId);
                                if (fullSession.session.answers) {
                                    // Handle multiple viewer answers
                                    const answers = Array.isArray(fullSession.session.answers) 
                                        ? fullSession.session.answers 
                                        : [fullSession.session.answers];
                                    
                                    for (const answer of answers) {
                                        if (answer && peerConnection.signalingState === 'have-local-offer') {
                                            await peerConnection.setRemoteDescription(answer);
                                        }
                                    }
                                }
                            }
                            
                            // Update viewer count
                            elements.viewerCount.textContent = sessionData.viewerCount || 0;
                            
                        } else {
                            // Viewer: check for offer
                            if (sessionData.hasOffer && !peerConnection.currentRemoteDescription) {
                                const fullSession = await API.getWebRTCSession(currentSessionId);
                                const offer = fullSession.session.offer;
                                
                                if (offer) {
                                    await peerConnection.setRemoteDescription(offer);
                                    
                                    // Create and send answer
                                    const answer = await peerConnection.createAnswer();
                                    await peerConnection.setLocalDescription(answer);
                                    await API.sendAnswer(currentSessionId, answer);
                                }
                            }
                            
                            // Handle incoming candidates
                            if (sessionData.candidates && sessionData.candidates.length > 0) {
                                for (const candidate of sessionData.candidates) {
                                    await peerConnection.addIceCandidate(candidate);
                                }
                            }
                        }
                        
                    } catch (error) {
                        console.error('Error during WebRTC polling:', error);
                    }
                }, 2000); // Poll every 2 seconds
            },
            
            stopPolling() {
                if (pollingInterval) {
                    clearInterval(pollingInterval);
                    pollingInterval = null;
                }
            },
            
            // Connection metrics
            startConnectionMetrics() {
                if (metricsInterval) {
                    clearInterval(metricsInterval);
                }
                
                metricsInterval = setInterval(async () => {
                    if (!peerConnection) return;
                    
                    try {
                        const stats = await peerConnection.getStats();
                        let bitrate = 0;
                        let packets = 0;
                        let jitter = 0;
                        let rtt = 0;
                        
                        stats.forEach(report => {
                            if (report.type === 'inbound-rtp' && report.kind === 'video') {
                                bitrate = report.bitrate || 0;
                                packets = report.packetsReceived || 0;
                                jitter = report.jitter || 0;
                            }
                            if (report.type === 'candidate-pair' && report.nominated) {
                                rtt = report.currentRoundTripTime * 1000 || 0;
                            }
                        });
                        
                        elements.metricBitrate.textContent = Math.round(bitrate / 1024);
                        elements.metricPackets.textContent = packets;
                        elements.metricJitter.textContent = Math.round(jitter * 1000);
                        elements.metricRtt.textContent = Math.round(rtt);
                        elements.metricsPanel.classList.remove('hidden');
                        
                    } catch (error) {
                        console.error('Error getting connection metrics:', error);
                    }
                }, 1000);
            },
            
            stopConnectionMetrics() {
                if (metricsInterval) {
                    clearInterval(metricsInterval);
                    metricsInterval = null;
                }
            },
            
            showStreamingAlert(message, type = 'error') {
                elements.streamingAlert.textContent = message;
                elements.streamingAlert.className = `alert alert-${type}`;
                elements.streamingAlert.classList.remove('hidden');
                
                setTimeout(() => {
                    elements.streamingAlert.classList.add('hidden');
                }, 5000);
            }
        };

        // App management
        const AppManager = {
            async init() {
                await this.loadCameras();
                await this.loadEvents();
                await this.loadActiveStreams();
                this.setupEventListeners();
            },
            
            async loadCameras() {
                try {
                    const result = await API.getCameras();
                    cameras = result.cameras;
                    this.renderCameras();
                } catch (error) {
                    this.showCamerasAlert(`Failed to load cameras: ${error.message}`, 'error');
                }
            },
            
            async loadEvents() {
                try {
                    const result = await API.getEvents();
                    events = result.events;
                    this.renderEvents();
                } catch (error) {
                    console.error('Failed to load events:', error);
                }
            },
            
            async loadActiveStreams() {
                try {
                    const result = await API.getStreams();
                    activeStreams = result.streams;
                    this.renderStreamSelector();
                } catch (error) {
                    console.error('Failed to load active streams:', error);
                }
            },
            
            renderCameras() {
                elements.camerasGrid.innerHTML = '';
                
                if (cameras.length === 0) {
                    elements.camerasGrid.innerHTML = `
                        <div style="grid-column: 1 / -1; text-align: center; padding: 2rem; color: var(--gray-600);">
                            No cameras yet. Click "Add Camera" to get started.
                        </div>
                    `;
                    return;
                }
                
                cameras.forEach(camera => {
                    const card = document.createElement('div');
                    card.className = 'camera-card';
                    card.innerHTML = `
                        <div class="camera-header">
                            <div>
                                <div class="camera-name">${camera.name}</div>
                                <div class="camera-location">${camera.location}</div>
                            </div>
                            <span class="camera-status status-${camera.status}">
                                ${camera.status === 'streaming' ? '● Streaming' : '● Offline'}
                            </span>
                        </div>
                        <div class="camera-info">
                            <div style="font-size: 0.875rem; color: var(--gray-600);">
                                Quality: ${camera.quality} | ID: ${camera.id}
                            </div>
                        </div>
                        <div class="camera-actions">
                            <button class="btn btn-primary btn-sm" onclick="AppManager.startCameraStream('${camera.id}', '${camera.name}')">
                                Start Stream
                            </button>
                            <button class="btn btn-outline btn-sm" onclick="AppManager.deleteCamera('${camera.id}')">
                                Delete
                            </button>
                        </div>
                    `;
                    elements.camerasGrid.appendChild(card);
                });
            },
            
            renderEvents() {
                elements.eventsList.innerHTML = '';
                
                if (events.length === 0) {
                    elements.eventsList.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: var(--gray-600);">
                            No events yet.
                        </div>
                    `;
                    return;
                }
                
                events.slice(0, 10).forEach(event => {
                    const eventItem = document.createElement('div');
                    eventItem.className = 'event-item';
                    
                    const typeClass = event.type.includes('error') ? 'type-warning' : 
                                    event.type.includes('success') ? 'type-success' : 'type-info';
                    
                    eventItem.innerHTML = `
                        <div>
                            <div style="font-weight: 500;">${event.description}</div>
                            <div style="font-size: 0.875rem; color: var(--gray-600);">
                                ${new Date(event.timestamp).toLocaleString()}
                            </div>
                        </div>
                        <span class="event-type ${typeClass}">${event.type}</span>
                    `;
                    elements.eventsList.appendChild(eventItem);
                });
            },
            
            renderStreamSelector() {
                elements.streamSelector.innerHTML = '<option value="">Select a stream...</option>';
                
                activeStreams.forEach(stream => {
                    const option = document.createElement('option');
                    option.value = stream.id;
                    option.textContent = `${stream.cameraName} (${stream.id})`;
                    elements.streamSelector.appendChild(option);
                });
            },
            
            async startCameraStream(cameraId, cameraName) {
                await WebRTCManager.startStreaming(cameraId, cameraName);
            },
            
            async deleteCamera(cameraId) {
                if (!confirm('Are you sure you want to delete this camera?')) {
                    return;
                }
                
                try {
                    await API.deleteCamera(cameraId);
                    this.showCamerasAlert('Camera deleted successfully', 'success');
                    await this.loadCameras();
                } catch (error) {
                    this.showCamerasAlert(`Failed to delete camera: ${error.message}`, 'error');
                }
            },
            
            async createCamera(cameraData) {
                try {
                    await API.createCamera(cameraData);
                    this.hideCameraModal();
                    this.showCamerasAlert('Camera created successfully', 'success');
                    await this.loadCameras();
                } catch (error) {
                    this.showCamerasAlert(`Failed to create camera: ${error.message}`, 'error');
                }
            },
            
            showCameraModal() {
                elements.cameraModal.classList.remove('hidden');
            },
            
            hideCameraModal() {
                elements.cameraModal.classList.add('hidden');
                elements.cameraForm.reset();
            },
            
            showCamerasAlert(message, type = 'error') {
                elements.camerasAlert.textContent = message;
                elements.camerasAlert.className = `alert alert-${type}`;
                elements.camerasAlert.classList.remove('hidden');
                
                setTimeout(() => {
                    elements.camerasAlert.classList.add('hidden');
                }, 5000);
            },
            
            setupEventListeners() {
                // Camera form
                elements.cameraForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const formData = new FormData(e.target);
                    const cameraData = {
                        name: formData.get('name'),
                        location: formData.get('location'),
                        quality: formData.get('quality')
                    };
                    this.createCamera(cameraData);
                });
                
                // Stream controls
                elements.startStreamBtn.addEventListener('click', () => {
                    if (cameras.length === 0) {
                                        this.showCamerasAlert('Please create a camera first', 'error');
                                        return;
                                    }
                                    // Use the first camera for demo purposes
                                    const camera = cameras[0];
                                    this.startCameraStream(camera.id, camera.name);
                                });
                
                elements.stopStreamBtn.addEventListener('click', () => {
                    WebRTCManager.stopStreaming();
                });
                
                elements.startViewerBtn.addEventListener('click', () => {
                    const streamId = elements.streamSelector.value;
                    if (!streamId) {
                        WebRTCManager.showStreamingAlert('Please select a stream', 'error');
                        return;
                    }
                    WebRTCManager.startViewer(streamId);
                });
                
                elements.stopViewerBtn.addEventListener('click', () => {
                    WebRTCManager.disconnectViewer();
                });
                
                elements.refreshCamerasBtn.addEventListener('click', () => {
                    this.loadCameras();
                    this.loadActiveStreams();
                });
                
                elements.refreshEventsBtn.addEventListener('click', () => {
                    this.loadEvents();
                });
                
                elements.cancelCameraBtn.addEventListener('click', () => {
                    this.hideCameraModal();
                });
            }
        };

        // Auth form handling
        let isLoginMode = true;
        
        function switchAuthMode() {
            isLoginMode = !isLoginMode;
            
            elements.authTitle.textContent = isLoginMode ? 'Login' : 'Register';
            elements.authSubmitText.textContent = isLoginMode ? 'Login' : 'Register';
            elements.authSwitch.textContent = isLoginMode ? 'Switch to Register' : 'Switch to Login';
            elements.nameGroup.classList.toggle('hidden', isLoginMode);
        }
        
        async function handleAuthSubmit(e) {
            e.preventDefault();
            
            const formData = new FormData(e.target);
            const authData = {
                email: formData.get('email'),
                password: formData.get('password')
            };
            
            if (!isLoginMode) {
                authData.name = formData.get('name');
            }
            
            try {
                elements.authSubmit.disabled = true;
                elements.authSubmit.classList.add('loading');
                
                if (isLoginMode) {
                    await AuthManager.login(authData);
                } else {
                    await AuthManager.register(authData);
                }
                
                e.target.reset();
            } catch (error) {
                // Error handled in AuthManager
            } finally {
                elements.authSubmit.disabled = false;
                elements.authSubmit.classList.remove('loading');
            }
        }

        // Initialize app
        document.addEventListener('DOMContentLoaded', () => {
            // Set up auth event listeners
            elements.authForm.addEventListener('submit', handleAuthSubmit);
            elements.authSwitch.addEventListener('click', switchAuthMode);
            elements.logoutBtn.addEventListener('click', () => AuthManager.logout());
            elements.addCameraBtn.addEventListener('click', () => AppManager.showCameraModal());
            
            // Check if user is already logged in
            if (AuthManager.loadFromStorage()) {
                console.log('User loaded from storage');
            }
        });

        // Make managers globally available for onclick handlers
        window.AppManager = AppManager;
        window.WebRTCManager = WebRTCManager;
    </script>
</body>
</html>
